<?php
/**
 * @file
 * Code for the Loop External data functionality.
 */

include_once 'loop_external_data.features.inc';
include 'parser.php';
include 'iParser.inc';
include 'LoopNode.php';
include 'LoopIndex.php';
include 'Leaf.php';
include 'Tree.php';

/**
 * Implements hook_menu().
 */
function loop_external_data_menu() {
  $items['index/%node'] = array(
    'title' => 'Node',
    'page callback' => 'loop_external_data_index',
    'access arguments' => array('access content'),
    'page arguments' => array(1),
    'type' => MENU_SUGGESTED_ITEM,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function loop_external_data_theme($existing, $type, $theme, $path) {
  return array(
    'loop_external_data_index' => array(
      'variables' => array(
        'forest' => NULL,
      ),
      'template' => 'templates/loop-external-data-index',
    ),
    'loop_external_data_trees' => array(
      'variables' => array(
        'title' => NULL,
        'nid' => NULL,
        'childs' => array(),
      ),
      'template' => 'templates/loop-external-data-trees',
    ),
    'loop_external_data_leaf' => array(
      'variables' => array(
        'title' => NULL,
        'nid' => NULL,
        'body' => NULL,
      ),
      'template' => 'templates/loop-external-data-leaf',
    ),
    'loop_external_data_dropdown_block' => array(
      'variables' => array(
        'forest' => NULL,
      ),
      'template' => 'templates/loop-external-data-dropdown-block',
    ),
    'loop_external_data_dropdown_trees' => array(
      'variables' => array(
        'title' => NULL,
        'nid' => NULL,
        'childs' => NULL,
      ),
      'template' => 'templates/loop-external-data-dropdown-trees',
    ),
    'loop_external_data_dropdown_leaf' => array(
      'variables' => array(
        'title' => NULL,
        'nid' => NULL,
        'childs' => NULL,
      ),
      'template' => 'templates/loop-external-data-dropdown-leaf',
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function loop_external_data_block_info() {
  $blocks['index'] = array(
    'info' => t('Index'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function loop_external_data_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'index':
      $node_id = (int)arg(1);
      if ( (is_int($node_id)) && ($node_id > 0) ) {
        $node = node_load($node_id);
        $node = _loop_external_data_find_index($node);
        $block['subject'] = t('Index');
        $block['content'] = array(
          '#theme' => 'loop_external_data_dropdown_block',
          '#forest' => _loop_external_data_build_dropdown($node)
        );
      }
      break;
  }
  return $block;
}

/**
 * Internal function to build fully tree recursive.
 *
 * @param $item
 *   Index/tree/leaf object.
 *
 * @return array
 *   Fully recursive tree.
 */
function _loop_external_data_build_dropdown($item) {
  $wrapper = entity_metadata_wrapper('node', $item);

  $items = array();

  switch ($item->type) {
    case 'index':
      $trees = $wrapper->field_tree->value();
      foreach ($trees as $tree) {
        $items['childs'][] = _loop_external_data_build_dropdown($tree);
        $items['#theme'] = 'loop_external_data_dropdown_trees';
      }
      break;
    case 'tree':
      $items['#title'] = $item->title;
      $items['#nid'] = $item->nid;
      $leafs = $wrapper->field_leaf->value();
      foreach ($leafs as $child) {
        if ($child->type == 'tree') {
          $items['#childs'][] = _loop_external_data_build_dropdown($child);
          $items['#theme'] = 'loop_external_data_dropdown_trees';
        }
        else {
          $new_child['#theme'] = 'loop_external_data_dropdown_leaf';
          $new_child['#title'] = $child->title;
          $new_child['#nid'] = $child->nid;
          $items['#childs'][] = $new_child;
          $items['#theme'] = 'loop_external_data_dropdown_trees';
        }
      }
      break;
  }

  return $items;
}

function _loop_external_data_find_index($item) {
  // Find index.
  if ($item->type != 'index') {
    $tree = db_select('field_data_field_leaf', 'l')
      ->fields('l', array('entity_id'))
      ->condition('field_leaf_target_id', $item->nid)
      ->execute()
      ->fetchAssoc();

    if ($tree == FALSE) {
      $tree = db_select('field_data_field_tree', 'l')
        ->fields('l', array('entity_id'))
        ->condition('field_tree_target_id', $item->nid)
        ->execute()
        ->fetchAssoc();
    }

    $item = node_load($tree['entity_id']);
    return _loop_external_data_find_index($item);
  }
  else {
    return $item;
  }
}

/**
 * Build render array with index.
 *
 * @param $node
 *   The Index node.
 *
 * @return array
 *   Array ready to render.
 */
function loop_external_data_index($node) {
  if ($node->type == 'index') {
    drupal_set_title($node->title);
    $forest = _loop_external_data_build_tree($node);

    // Return render array.
    return array(
      '#theme' => 'loop_external_data_index',
      '#forest' => $forest
    );
  }
  else {
    return array(
      '#theme' => 'loop_external_data_index',
      '#forest' => array()
    );
  }
}

/**
 * Internal function to build fully tree recursive.
 *
 * @param $item
 *   Index/tree/leaf object.
 *
 * @return array
 *   Fully recursive tree.
 */
function _loop_external_data_build_tree($item) {
  $wrapper = entity_metadata_wrapper('node', $item);

  $items = array();

  switch ($item->type) {
    case 'index':
      $trees = $wrapper->field_tree->value();
      foreach ($trees as $tree) {
        $items['childs'][] = _loop_external_data_build_tree($tree);
        $items['#theme'] = 'loop_external_data_trees';
      }
      break;
    case 'tree':
      $items['#title'] = $item->title;
      $items['#nid'] = $item->nid;
      $leafs = $wrapper->field_leaf->value();
      foreach ($leafs as $child) {
        if ($child->type == 'tree') {
          $items['#childs'][] = _loop_external_data_build_tree($child);
          $items['#theme'] = 'loop_external_data_trees';
        }
        else {
          $new_child['#theme'] = 'loop_external_data_leaf';
          $new_child['#title'] = $child->title;
          $display = array('label' => 'hidden');
          $new_child['#body'] = field_view_field('node', $child, 'body', $display);
          $new_child['#nid'] = $child->nid;
          $items['#childs'][] = $new_child;
          $items['#theme'] = 'loop_external_data_trees';
        }
      }
      break;
  }

  return $items;
}

/**
 * Implements hook_node_insert().
 *
 * @param $node
 */
function loop_external_data_node_insert($node) {
  if ($node->type == 'index') {
    _loop_external_data_file_load($node);
  }
}

/**
 * Implements hook_node_update().
 *
 * @param $node
 */
function loop_external_data_node_update($node) {
  if (!isset($_SESSION['loop_external_data_node_update'])) {
    if ( ($node->created < $node->changed) && ($node->type == 'index') ) {
      $_SESSION['loop_external_data_node_update'] = time() + 10;
      // This is an update, remove old data.
      $trees = _loop_external_data_build_tree($node);
      _loop_external_data_delete_tree($trees);

      // Build new data.
      _loop_external_data_file_load($node);
    }
  }
  else {
    if (time() < $_SESSION['loop_external_data_node_update']) {
      unset ($_SESSION['loop_external_data_node_update']);
    }
  }
}

/**
 * Recursively deletes a tree of nodes.
 *
 * @param $trees
 */
function _loop_external_data_delete_tree($trees) {
  foreach ($trees['childs'] as $tree) {
    if (is_object($tree)) {
      node_delete($tree->nid);
    }
    else if (is_array($tree['childs'])) {
      node_delete($tree['nid']);
      _loop_external_data_delete_tree($tree);
    }
  }
}

/**
 * Load uploaded file and send it to our parser.
 *
 * @param $node
 *   Index node.
 */
function _loop_external_data_file_load($node) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $file_fid = $wrapper->field_file->value();

  $file = file_load($file_fid['fid']);

  // Set up parser and parse the zip file.
  $parser = new Parser();
  $data = $parser->parse(drupal_realpath($file->uri), drupal_realpath('public://index_file/' . $file->fid), $node->nid);

  // Check if data is returned.
  if (!empty($data)) {
    // Send data and node id to parser.
    _loop_external_data_parser($data, $node->nid);
  }

  // Remove the unzip directory.
  file_unmanaged_delete_recursive('public://index_file/' . $file->fid . '/');
}

/**
 * Recursive data parser.
 *
 * @param $data
 *   Index/tree/leaf object.
 *
 * @param int $parent
 *   Parent node ID.
 * @param array $references
 *   Array of references.
 */
function _loop_external_data_parser($data, $parent = NULL, &$references = NULL) {
  // Figure out what type we got.
  $class_type = get_class($data);
  switch ($class_type) {
    case 'LoopIndex':
      _loop_external_data_parser_index($data, $parent);
      break;
    case 'Tree':
      _loop_external_data_parser_tree($data, $parent, $references);
      break;
    case 'Leaf':
      _loop_external_data_parser_leaf($data, $parent, $references);
      break;
  }

  return $data;
}

/**
 * Parse index object.
 *
 * @param $index
 *   Index object.
 *
 * @param $parent
 *   Parent node ID.
 */
function _loop_external_data_parser_index($index, $parent) {
  $children = $index->getChildren();
  $references = $index->getReferences();

  if (!empty($children)) {
    foreach ($children as $child) {
      _loop_external_data_parser($child, $parent, $references);
    }

    $msg = array(
      'message'=>'references printout',
      'references'=>$references
    );
    watchdog('loop_external_data', print_r($msg, 1));

    // Fix references
    foreach ($children as $child) {
      $class_type = get_class($child);
      switch ($class_type) {
        case 'Tree':
          _loop_external_data_fix_references_tree($child, $references);
          break;
        case 'Leaf':
          _loop_external_data_fix_references_leaf($child, $references);
          break;
      }
    }
  }
}

/**
 * Fixes references for a Tree.
 *
 * @param $loopTree
 * @param $references
 */
function _loop_external_data_fix_references_tree($loopTree, $references) {
  $children = $loopTree->getChildren();
  foreach($children as $child) {
    $class_type = get_class($child);
    switch ($class_type) {
      case 'Tree':
        _loop_external_data_fix_references_tree($child, $references);
        break;
      case 'Leaf':
        _loop_external_data_fix_references_leaf($child, $references);
        break;
    }
  }
}

/**
 * Fixes the references for the body of a Leaf.
 * Uses the $references array to make the links between nodes.
 *
 * @param $loopLeaf
 * @param $references
 * @throws Exception
 */
function _loop_external_data_fix_references_leaf($loopLeaf, $references) {
  $node = node_load($loopLeaf->getDrupalNID());

  $wrapper = entity_metadata_wrapper('node', $node);
  $body = $wrapper->body->value();

  $xml = new DOMDocument('1.0', 'utf-8');
  libxml_use_internal_errors(true);
  if (!$xml->loadHTML($body['value'])) {
    throw new Exception("Error loading Leaf body.");
  }
  libxml_clear_errors();
  $xpath = new DOMXPath($xml);

  foreach ($xpath->query('//a') as $a) {
    $href = $a->getAttribute('href');

    $ref = $references[$href];
    if (isset($ref)) {
      $newPath = '/node/' . $ref['nid'];

      $a->setAttribute('href', $newPath);
      $a->setAttribute('class', 'external-data-link');
    }
  }

  $body = $xpath->query('//body');

  $bodyArr = array(
    'value' => $xml->saveXML($body->item(0)),
    'format' => 'editor'
  );

  $wrapper->body = $bodyArr;
  $wrapper->save();
}

/**
 * Parse tree object.
 *
 * Creates a tree node and recursively parse childs.
 *
 * @param $tree
 *   Tree object.
 *
 * @param int $parent
 *  Parent node ID.
 * @param array $references
 *  Array of references.
 */
function _loop_external_data_parser_tree($tree, $parent = NULL, &$references) {
  global $user;
  $node = new Stdclass();

  $node->type = 'tree';
  $node->language = LANGUAGE_NONE;
  $node->status = 1;
  $node->uid = $user->uid;
  $node->title = $tree->getTitle();

  node_save($node);

  $children = $tree->getChildren();
  foreach ($children as $child) {
    _loop_external_data_parser($child, $node->nid, $references);
  }

  _loop_external_data_add_child($parent, $node);
}

/**
 * Parse leaf object.
 *
 * Creates a leaf node.
 *
 * @param $leaf
 *   Leaf object.
 *
 * @param int $parent
 *  Parent node ID.
 * @param array $references
 *  Array of references.
 */
function _loop_external_data_parser_leaf($leaf, $parent = NULL, &$references) {
  global $user;
  $node = new Stdclass();

  $node->type = 'leaf';
  $node->language = LANGUAGE_NONE;
  $node->status = 1;
  $node->uid = $user->uid;
  $node->title = $leaf->getTitle();

  node_save($node);

  // If this leaf matches one of the references, set the node id of the reference.
  for ($i = 0; $i < count($references); $i++) {
    if ($references[$i]['leafID'] == $leaf->getLeafID()) {
      $references[$i]['nid'] = $node->nid;
    }
  }

  // Add Node ID to leaf.
  $leaf->setDrupalNID($node->nid);

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->body = array(
    'value' => $leaf->getBody(),
    'format' => 'editor'
  );
  $wrapper->save();

  _loop_external_data_add_child($parent, $node);
}

/**
 * Adds nodes to parent.
 *
 * @param $node
 *   Node object.
 *
 * @param $child
 *   Node object.
 */
function _loop_external_data_add_child($node, $child) {
  $parentNode = node_load($node);
  $wrapper = entity_metadata_wrapper('node', $parentNode);
  if ($parentNode->type == 'tree') {
    $wrapper->field_leaf[] = intval($child->nid);
  }
  else if ($parentNode->type == 'index') {
    $wrapper->field_tree[] = intval($child->nid);
  }

  $wrapper->save();
}
